So to help pay the bills (particularly the airfare to Japan in the summer) I've taken on a closed source private coding project.  I really prefer to work exclusively on open source, but at the moment it doesn't seem to pay quite so well.  However I've very kindly been given permission to blog about the closed source coding that I'm doing, with the proviso that I don't show any of the code.  That allows me to blog about the architecture and development in general, which I think will help me working on the project and perhaps help others thinking about the evolution of code, prototyping and software architecture in general.

The application in is in the general field of translation support, and currently consists of a prototype written in JavaScript and using the electron framework in order to provide for a cross-platform desktop user experience.  The basic translation support functionality is in place, and the app works well on a number of platforms.  We're now in the process of adding a variety of other features that the main developer and the domain expert believe are necessary for the application to be useful to the target users.  The domain expert is themself a member of the target user group, so we have a good deal of faith in their opinion ...

As far as the prototype goes, the electron set up means that we have a front end and back end as part of the same package.  They run in separate threads and communicate via message passing.  We have unit tests and acceptance tests via spectron, which I helped set up last year.  The acceptance tests all pass on the main developers linux machine, but a few of them fail on my OSX box, and we're not sure why.  I'm starting to feel pretty comfortable with the front end/back end split having just implemented a pre-editor for the system, which allows folks to make an initial edit to the file to be translated. There's more work to be done on testing for that, but right now we're trying to architect something bigger involving project support, so that rather than loading file by file, each file now becomes it's own project with associated meta-data.

At the moment all the front end and back end code is in the same directory.  The majority of the front end code is in main.js.  This file is currently over 1000 lines long.  Sandi Metz would have a heart attack, but no judgement here.  Getting a working prototype together to secure funding makes total sense.  Part of the value I can potentially add here is refactoring out a structure that will be more manageable going forward.  Most of the front end code is in a file called frontend.js, and creating the pre-editor I put all the related code into a separate file.   I've done the same for the front end component of the new projects manager element, but what we're wrestling with now is adjusting not just the front end, but the whole app to work with this new project opening flow.

Compared to what I'm used to the function lengths in the app are pretty long.  The main developer has intimate knowledge of the app, and I often find myself getting lost in the system.  I had started with a sketch of the projects front end that was displaying a hard coded fixed list of projects.  Over the weekend when I connected the project manager front end to the unit-tested project class I found that we were trying to open all the projects when we scanned for them, and that wouldn't work since the DocumentParser object wasn't available in the general case.

The main developer adjusted that, and now projects get loaded into the project manager view, but the next step is managing the flow so that we don't re-create a new project every time we save things.  I'm having trouble remembering where we are doing that and am thinking about whether to get some acceptance tests in place to manage all this.  You might say, what, of course the acceptance tests should come first.  However, two things.  One, the spectron tests seem very brittle on my machine, and allow for wasting an almost unlimited amount of time if I'm not careful.  Two, just to get my head round the existing project code and how things might fit into place required me to spike something just to see what we were dealing with.  Of course maybe that just means I am an insufficiently skilled or undisciplined developer.   So, throw out the spike and drive from acceptance tests?  Wrap acceptance tests around the spike? Or drive deeper into the spike ...?
